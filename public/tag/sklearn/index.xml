<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sklearn | DYLAN WIWAD, Ph.D</title>
    <link>/tag/sklearn/</link>
      <atom:link href="/tag/sklearn/index.xml" rel="self" type="application/rss+xml" />
    <description>sklearn</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 07 Oct 2018 00:00:00 -0500</lastBuildDate>
    <image>
      <url>/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>sklearn</title>
      <link>/tag/sklearn/</link>
    </image>
    
    <item>
      <title>Maching Learning Tutorial: Predicting Car Prices with K-Nearest Neighbours (KNN) Regression</title>
      <link>/project/car_prices/</link>
      <pubDate>Sun, 07 Oct 2018 00:00:00 -0500</pubDate>
      <guid>/project/car_prices/</guid>
      <description>&lt;h1 id=&#34;predicting-car-prices-with-knn-regression&#34;&gt;Predicting Car Prices with KNN Regression&lt;/h1&gt;
&lt;p&gt;In this brief tutorial I am going to run through how to build, implement, and cross-validate a simple k-nearest neighbours (KNN) regression model. Simply put, KNN model is a variant of simple linear regression wherein we utilize information about neighbouring data points to predict an unknown outcome. To put a more concrete spin on this, and use the name quite literally, we can think about this in the context of your next door neighbours. If the outcome I wanted to predict was your personal income and didn&amp;rsquo;t have any other information about you, besides where you live, I might be wise to just ask your next door neighbours. I might decide to run a real life 4-nearest neighbours test. The two houses to the right of yours have a household incomes of $65,000 and $90,000 respectively, and the two to the left $100,000 and $72,000. In the simplest possible fashion I would then just assume you make somewhere in the ballpark of what your neighbours make, take an average, and predict that you have a household income of $81,750.&lt;/p&gt;
&lt;p&gt;This is an extremely basic explanation of how KNN algorithms work. But how do we decide who someone&amp;rsquo;s &amp;ldquo;neighbours&amp;rdquo; are when we aren&amp;rsquo;t talking about literal neighbours? That is, how do we know what other observations are similar to our target? Enter: distance metrics. The most common distance metric in for knn regression problems is 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Euclidean_distance&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Euclidian distance&lt;/a&gt;. This isn&amp;rsquo;t meant to be an extremely math heavy tutorial, so suffice it to say that in running a knn model, for each and every observation in a data set where we want to predict an outcome we grab their k-nearest neighbours, as defined by a metric such as Euclidean distance, from the training set, look at their values for the main dependent variable, and predict the new value based on the neighbours (e.g., as an average in a regression problem, or a &amp;ldquo;majority vote&amp;rdquo; in a classification problem).&lt;/p&gt;
&lt;p&gt;KNN regression can be used for both classification (i.e., predicting a binary outcome) and regression (i.e., predicting a continuous outcome). The procedure for implementation is largely the same and in this post I&amp;rsquo;m going to focus on regression. Specifically, the question at hand is: &lt;strong&gt;can we predict how much a used car is going to sell for?&lt;/strong&gt; For this question I am going to utilize a data set from the 
&lt;a href=&#34;https://archive.ics.uci.edu/ml/datasets/automobile&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;machine learning repository at The University of California, Irvine&lt;/a&gt;. First up is to just take a brief look at what is actually in the dataset.&lt;/p&gt;
&lt;h2 id=&#34;brief-exploratory-analysis-and-cleaning&#34;&gt;Brief Exploratory Analysis and Cleaning&lt;/h2&gt;
&lt;p&gt;These data contain a ton of information on a lot of different cars. For the purposes of this tutorial, I&amp;rsquo;m just going to pull out a set of relevant columns and work with those.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd

# Need to specify the headers for this dataset
cols = [&amp;quot;symboling&amp;quot;, &amp;quot;normalized_losses&amp;quot;, &amp;quot;make&amp;quot;, &amp;quot;fuel_type&amp;quot;, &amp;quot;aspiration&amp;quot;,
       &amp;quot;num_doors&amp;quot;, &amp;quot;body_style&amp;quot;, &amp;quot;drive_wheels&amp;quot;, &amp;quot;engine_location&amp;quot;,
       &amp;quot;wheel_base&amp;quot;, &amp;quot;length&amp;quot;, &amp;quot;width&amp;quot;, &amp;quot;height&amp;quot;, &amp;quot;curb_weight&amp;quot;, &amp;quot;engine_type&amp;quot;,
       &amp;quot;num_cylinders&amp;quot;, &amp;quot;engine_size&amp;quot;, &amp;quot;fuel_system&amp;quot;, &amp;quot;bore&amp;quot;, &amp;quot;stroke&amp;quot;,
       &amp;quot;compression_ratio&amp;quot;, &amp;quot;horsepower&amp;quot;, &amp;quot;peak_rpm&amp;quot;, &amp;quot;city_mpg&amp;quot;, &amp;quot;highway_mpg&amp;quot;,
       &amp;quot;price&amp;quot;]
cars = pd.read_csv(&amp;quot;imports-85.data&amp;quot;, names=cols)
cars.dtypes

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;symboling              int64
normalized_losses     object
make                  object
fuel_type             object
aspiration            object
num_doors             object
body_style            object
drive_wheels          object
engine_location       object
wheel_base           float64
length               float64
width                float64
height               float64
curb_weight            int64
engine_type           object
num_cylinders         object
engine_size            int64
fuel_system           object
bore                  object
stroke                object
compression_ratio    float64
horsepower            object
peak_rpm              object
city_mpg               int64
highway_mpg            int64
price                 object
dtype: object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, as you can see we&amp;rsquo;ve got 25 columns that might be informative in predicting a car&amp;rsquo;s sale price, ranging from both highway and city miles per gallon to the number of doors a car has. Let&amp;rsquo;s take a quick look at the first few rows of the data just so we can get a sense of how it actually looks.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;cars.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;symboling&lt;/th&gt;
      &lt;th&gt;normalized_losses&lt;/th&gt;
      &lt;th&gt;make&lt;/th&gt;
      &lt;th&gt;fuel_type&lt;/th&gt;
      &lt;th&gt;...&lt;/th&gt;
      &lt;th&gt;horsepower&lt;/th&gt;
      &lt;th&gt;peak_rpm&lt;/th&gt;
      &lt;th&gt;city_mpg&lt;/th&gt;
      &lt;th&gt;highway_mpg&lt;/th&gt;
      &lt;th&gt;price&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;?&lt;/td&gt;
      &lt;td&gt;alfa-romero&lt;/td&gt;
      &lt;td&gt;gas&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;111&lt;/td&gt;
      &lt;td&gt;5000&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
      &lt;td&gt;13495&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;?&lt;/td&gt;
      &lt;td&gt;alfa-romero&lt;/td&gt;
      &lt;td&gt;gas&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;111&lt;/td&gt;
      &lt;td&gt;5000&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
      &lt;td&gt;16500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;?&lt;/td&gt;
      &lt;td&gt;alfa-romero&lt;/td&gt;
      &lt;td&gt;gas&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
      &lt;td&gt;5000&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;16500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;164&lt;/td&gt;
      &lt;td&gt;audi&lt;/td&gt;
      &lt;td&gt;gas&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;102&lt;/td&gt;
      &lt;td&gt;5500&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;13950&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;164&lt;/td&gt;
      &lt;td&gt;audi&lt;/td&gt;
      &lt;td&gt;gas&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;115&lt;/td&gt;
      &lt;td&gt;5500&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;17450&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;5 rows × 26 columns&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;To keep things simple and focus just on numeric columns without much feature engineering for now, it seems like we can use wheelbase, length, width, height, engine size, compression ratio, and city/highway mpr to predict price. Some of these predictors probably offer more information that others (miles per gallon is probably more informative of a car&amp;rsquo;s sale price than curb weight).&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;re probably going to want to use some of the other variables that aren&amp;rsquo;t numeric - they are likely also meaningful. So, right now we&amp;rsquo;ll deal with counting and seeing where our missing values are, as well as turning relevant columns numeric so we can actually use them. You will have noticed above that there were some questionmarks in the data - we just need to turn those into missing values. So I do this in the code below, then I select sex non-numeric columns that might be meaningful (normalized_losses, bore, stroke, horsepower, peak_rpm, and price) and turn them numeric. These ones are easy as they are actually numbers, they just are currently stored as objects.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np

cars = cars.replace(&#39;?&#39;, np.nan)

# Now lets make things numeric
num_vars = [&#39;normalized_losses&#39;, &amp;quot;bore&amp;quot;, &amp;quot;stroke&amp;quot;, &amp;quot;horsepower&amp;quot;, &amp;quot;peak_rpm&amp;quot;,
            &amp;quot;price&amp;quot;]

for i in num_vars:
    cars[i] = cars[i].astype(&#39;float64&#39;)
    
cars.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;symboling&lt;/th&gt;
      &lt;th&gt;normalized_losses&lt;/th&gt;
      &lt;th&gt;make&lt;/th&gt;
      &lt;th&gt;fuel_type&lt;/th&gt;
      &lt;th&gt;...&lt;/th&gt;
      &lt;th&gt;horsepower&lt;/th&gt;
      &lt;th&gt;peak_rpm&lt;/th&gt;
      &lt;th&gt;city_mpg&lt;/th&gt;
      &lt;th&gt;highway_mpg&lt;/th&gt;
      &lt;th&gt;price&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;alfa-romero&lt;/td&gt;
      &lt;td&gt;gas&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;111.0&lt;/td&gt;
      &lt;td&gt;5000.0&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
      &lt;td&gt;13495.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;alfa-romero&lt;/td&gt;
      &lt;td&gt;gas&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;111.0&lt;/td&gt;
      &lt;td&gt;5000.0&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
      &lt;td&gt;16500.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;alfa-romero&lt;/td&gt;
      &lt;td&gt;gas&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;154.0&lt;/td&gt;
      &lt;td&gt;5000.0&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;16500.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;164.0&lt;/td&gt;
      &lt;td&gt;audi&lt;/td&gt;
      &lt;td&gt;gas&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;102.0&lt;/td&gt;
      &lt;td&gt;5500.0&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;13950.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;164.0&lt;/td&gt;
      &lt;td&gt;audi&lt;/td&gt;
      &lt;td&gt;gas&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;115.0&lt;/td&gt;
      &lt;td&gt;5500.0&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;17450.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;5 rows × 26 columns&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Everything looks good now - how many missing values do we have in the normalized losses column?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(&amp;quot;normalized losses: &amp;quot;, cars[&#39;normalized_losses&#39;].isnull().sum())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;normalized losses:  41
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are 41 missing values in the normalized_losses column. Given there are only 205 rows, thats a decent chunk missing. I&amp;rsquo;m not sure this column is the most useful, so we&amp;rsquo;ll just not use this column in our analyses at all. Let&amp;rsquo;s take a look at our other numeric columns and see what the missing values are like. The below chunk just calculates the sum of missing values for each variable and displays that sum.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;cars.isnull().sum()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;symboling             0
normalized_losses    41
make                  0
fuel_type             0
aspiration            0
num_doors             2
body_style            0
drive_wheels          0
engine_location       0
wheel_base            0
length                0
width                 0
height                0
curb_weight           0
engine_type           0
num_cylinders         0
engine_size           0
fuel_system           0
bore                  4
stroke                4
compression_ratio     0
horsepower            2
peak_rpm              2
city_mpg              0
highway_mpg           0
price                 4
dtype: int64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So it looks like most of our columns are pretty good, with only a couple missing values here and there. The most crucial one here is price, our dependent variable; there are four cars that don&amp;rsquo;t have prices. Given that the number of missing rows is, at most, about 2%, I&amp;rsquo;m just going to listwise delete any row that has a missing variable in any of these. I don&amp;rsquo;t like mean imputation as it is purely making up data.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ll start with the price column because its the most important and I suspect the rows that are missing price are the same rows missing the other data as well. Here I just drop any rows that are missing price data:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;cars = cars.dropna(subset = [&#39;price&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now lets check the missing values again, just to be sure it worked correctly:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;cars.isnull().sum()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;symboling             0
normalized_losses    37
make                  0
fuel_type             0
aspiration            0
num_doors             2
body_style            0
drive_wheels          0
engine_location       0
wheel_base            0
length                0
width                 0
height                0
curb_weight           0
engine_type           0
num_cylinders         0
engine_size           0
fuel_system           0
bore                  4
stroke                4
compression_ratio     0
horsepower            2
peak_rpm              2
city_mpg              0
highway_mpg           0
price                 0
dtype: int64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, I&amp;rsquo;ll do the same to listwise delete the other numeric columns.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;cars = cars.dropna(subset = [&#39;bore&#39;, &#39;stroke&#39;, &#39;horsepower&#39;, &#39;peak_rpm&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we should have no missing data and be ready to go! The next step is to convert all the numeric columns into standardized z-scores. This is especially important if your variables are on drastically different scales. For instance here, horsepower is generally way up over 100 and miles per gallon is never more than about 45. So what I&amp;rsquo;ll do below is trim the dataset down just to the numeric columns, and then convert each of those columns into a z-score. Then, I save this into a new dataset called &amp;ldquo;normalized.&amp;rdquo; This is generally good practice because that way we retain our original dataset in case we need to go back to it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;cols = [&#39;wheel_base&#39;, &#39;length&#39;, &#39;width&#39;, &#39;height&#39;,
        &#39;curb_weight&#39;, &#39;engine_size&#39;, &#39;bore&#39;, &#39;stroke&#39;, &#39;horsepower&#39;,
        &#39;peak_rpm&#39;, &#39;city_mpg&#39;, &#39;highway_mpg&#39;, &#39;price&#39;]
cars = cars[cols]

normalized_cars = (cars - cars.mean()) / (cars.std())
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;modeling&#34;&gt;Modeling&lt;/h2&gt;
&lt;p&gt;Alright, onward into some modeling! We&amp;rsquo;ve got a nice clean data set full of numeric columns. The first thing I&amp;rsquo;m going to do is create a couple of univariate (i.e., just one predictor) models, just to see how informative certain predictors are. Now, in more traditionally academic regression contexts this would be akin to just running some linear regressions with individual predictors. For example, we might see how well highway miles per gallon &amp;ldquo;predicts&amp;rdquo; sale price on it&amp;rsquo;s own. Of course, in the academic context, when we say predict what we actually mean is &amp;ldquo;variance explained&amp;rdquo; - we&amp;rsquo;re really finding out how much of the variance in sale price can be explained just by looking at highway miles per gallon.&lt;/p&gt;
&lt;p&gt;In the machine learning context, we are actually more concerned with &lt;em&gt;prediction&lt;/em&gt;. That is, if we build a KNN model, where we were only identifying neighbours based on how similar they were in highway miles per gallon, could we accurately predict price? There are myriad different ways we could judge accuracy, but here I&amp;rsquo;m going to use 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Root-mean-square_deviation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Root Mean Squared Error (RMSE)&lt;/a&gt;. RMSE is one of the most common error metrics for regression based machine learning. Again, this is not meant to be a math-heavy tutorial so I won&amp;rsquo;t go into it deeply here but it quantifies how far off our predictions were from the actual values.&lt;/p&gt;
&lt;p&gt;So, to start running some very basic univariate KNN models I imported two pieces of the sklearn package below, one for training a KNN model (KNeighborsRegressor) and one for calculating the mean squared error (mean_squared_error), from which we will derive the RMSE. Now, we need to do a couple things to build these models. Specifically, we need to choose the predictor we want to test, choose the dependent variable, and split our data into training and test sets so we reduce the risk of 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Overfitting&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;overfitting&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To accomplish this, I define a function that takes in three arguments: (1) our training column(s), (2), our target column, and (3) the dataset to use. Using this information, the function first instatiates an instance of a k-nearest neighbours regression (stored as &amp;ldquo;knn&amp;rdquo;) and sets a set so our results are reproducible. Next, the function shuffles the data into a random order, splits the data in half, designates the top half as the training data, and the bottom half as the test data.&lt;/p&gt;
&lt;p&gt;Then, we get down to the nitty gritty. The function fits the knn object on the specified training and test columns of the training data, uses that model to make predictions on the test data, and then calculates the RMSE (e.g., the difference between the predictions our model made for each car in the test set&amp;rsquo;s price and the actual prices).&lt;/p&gt;
&lt;p&gt;As we move through, we&amp;rsquo;ll complicate this function bit by bit, adding extra stuff to it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Writing a simple function that trains and tests univariate models
# This function takes in three arguments: the predictor, the outcome, &amp;amp; the data
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error

def knn_train_test(train_col, target_col, df):
    knn = KNeighborsRegressor()
    np.random.seed(1)
        
    # Randomize order of rows in data frame.
    shuffled_index = np.random.permutation(df.index)
    rand_df = df.reindex(shuffled_index)

    # Divide number of rows in half and round.
    last_train_row = int(len(rand_df) / 2)
    
    # Select the first half and set as training set.
    # Select the second half and set as test set.
    train_df = rand_df.iloc[0:last_train_row]
    test_df = rand_df.iloc[last_train_row:]
    
    # Fit a KNN model using default k value.
    knn.fit(train_df[[train_col]], train_df[target_col])
    
    # Make predictions using model.
    predicted_labels = knn.predict(test_df[[train_col]])

    # Calculate and return RMSE.
    mse = mean_squared_error(test_df[target_col], predicted_labels)
    rmse = np.sqrt(mse)
    return rmse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we&amp;rsquo;ve got this function defined, let&amp;rsquo;s use it! If you recall, I said I was going to just test some basic univariate models. So, I&amp;rsquo;m going to run our new function five times, getting the RMSE of five different predictors. I just chose four that I thought would be relatively meaningful in predicting price (city and highway miles per gallon, engine size, and horsepower) and one to serve as a logic check (width) - why would width predict the price of a car, unless larger vehicles are more expensive. In any case, my intuition suggests that width should be the word predictor of price.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Lets test a couple of predictors
print(&#39;city mpg: &#39;, knn_train_test(&#39;city_mpg&#39;, &#39;price&#39;, normalized_cars))
print(&#39;width: &#39;, knn_train_test(&#39;width&#39;, &#39;price&#39;, normalized_cars))
print(&#39;highway mpg: &#39;, knn_train_test(&#39;highway_mpg&#39;, &#39;price&#39;, normalized_cars))
print(&#39;engine size: &#39;, knn_train_test(&#39;engine_size&#39;, &#39;price&#39;, normalized_cars))
print(&#39;horsepower: &#39;, knn_train_test(&#39;horsepower&#39;, &#39;price&#39;, normalized_cars))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;city mpg:  0.598975486019
width:  0.671608148246
highway mpg:  0.537913994132
engine size:  0.536691465842
horsepower:  0.571585852136
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As I suspected, width is by quite a large margin the worst predictor of a car&amp;rsquo;s price. Of the couple predictors that I threw in there to test, the best most informative for determining a vehicles price seems to be it&amp;rsquo;s highway. So, if we wanted to be as accurate as possible while only using on predictor, we would want to use fuel economy on the highway.&lt;/p&gt;
&lt;h2 id=&#34;hyperparamaterization&#34;&gt;&amp;ldquo;Hyperparamaterization&amp;rdquo;&lt;/h2&gt;
&lt;p&gt;If you recall, in KNN regression, we can set k to be whatever we want: 3, 5, 7, 100, 1000. Common values of k range from 3 to 10 - does tweaking our k value, and grabbing more or less neighbours to make our price guess, make the model fit better? As a test of this question, I&amp;rsquo;m going to modify the above function to take another argument: a k value. Then, I&amp;rsquo;ll test each of the five predictors above (plus some more) each with five different values of k (1, 3, 5, 7, and 9). This will effectively run our regression 25 times; city mpg with 1 neighbour, city mpg with 2 neighbours, and so on.&lt;/p&gt;
&lt;p&gt;The way I&amp;rsquo;ve done this is to insert a list of k-values into the middle of the function, and set up an empty dictionary to store all our RMSEs. Then, I nested the code from previously that fits the model, generates our predictions, and calculates the RSME into a for loop that does this for each value of k. Lastly, it appends the RMSE to the dictionary and returns it.&lt;/p&gt;
&lt;p&gt;Lastly, I specified a list of all the columns I want to build univariate models for, use a for loop to run the function on each of those columns, and append the results to another dictionary called &amp;ldquo;k_rmse_results.&amp;rdquo; Printing this dictionary gives us the name of the predictor, the specified k, and then the RMSE.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def knn_train_test_new(train_col, target_col, df):
    np.random.seed(1)
        
    # Randomize order of rows in data frame.
    shuffled_index = np.random.permutation(df.index)
    rand_df = df.reindex(shuffled_index)

    # Divide number of rows in half and round.
    last_train_row = int(len(rand_df) / 2)
    
    # Select the first half and set as training set.
    # Select the second half and set as test set.
    train_df = rand_df.iloc[0:last_train_row]
    test_df = rand_df.iloc[last_train_row:]
    
    k_values = [1,3,5,7,9]
    k_rmses = {}
    
    for k in k_values:
        # Fit model using k nearest neighbors.
        knn = KNeighborsRegressor(n_neighbors=k)
        knn.fit(train_df[[train_col]], train_df[target_col])

        # Make predictions using model.
        predicted_labels = knn.predict(test_df[[train_col]])

        # Calculate and return RMSE.
        mse = mean_squared_error(test_df[target_col], predicted_labels)
        rmse = np.sqrt(mse)
        
        k_rmses[k] = rmse
    return k_rmses

k_rmse_results = {}

# For each column from above, train a model, return RMSE value
# and add to the dictionary `rmse_results`.
variables = [&#39;wheel_base&#39;, &#39;length&#39;, &#39;width&#39;, &#39;height&#39;,
        &#39;curb_weight&#39;, &#39;engine_size&#39;, &#39;bore&#39;, &#39;stroke&#39;, &#39;horsepower&#39;,
        &#39;peak_rpm&#39;, &#39;city_mpg&#39;, &#39;highway_mpg&#39;]

for var in variables:
    rmse_val = knn_train_test_new(var, &#39;price&#39;, normalized_cars)
    k_rmse_results[var] = rmse_val

k_rmse_results
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&#39;bore&#39;: {1: 1.2142304178718561,
  3: 0.86766581048215152,
  5: 0.89458788943880752,
  7: 0.94676716177240661,
  9: 0.95385344053196963},
 &#39;city_mpg&#39;: {1: 0.69529747854104784,
  3: 0.59031417913396289,
  5: 0.59897548601904338,
  7: 0.59715938629269016,
  9: 0.57728649652220132},
 &#39;curb_weight&#39;: {1: 0.8365387787670262,
  3: 0.64395375801733934,
  5: 0.57031290606074236,
  7: 0.51644149986604171,
  9: 0.51839468763038343},
 &#39;engine_size&#39;: {1: 0.55456842477058543,
  3: 0.54125650939355474,
  5: 0.53669146584152094,
  7: 0.51899873944760311,
  9: 0.50362821678292591},
 &#39;height&#39;: {1: 1.1521894508998922,
  3: 1.0168354498989998,
  5: 0.94018342361170537,
  7: 0.98192402693779424,
  9: 0.94562106614391528},
 &#39;highway_mpg&#39;: {1: 0.69402405950428248,
  3: 0.57416390399142236,
  5: 0.53791399413219376,
  7: 0.53495996840130122,
  9: 0.54899088943686292},
 &#39;horsepower&#39;: {1: 0.54931712010379319,
  3: 0.58337889657418729,
  5: 0.57158585213578872,
  7: 0.59314672824644243,
  9: 0.59002690698940097},
 &#39;length&#39;: {1: 0.65713817747103875,
  3: 0.63950652453727652,
  5: 0.64700844560860649,
  7: 0.66892394999830362,
  9: 0.6572441270128111},
 &#39;peak_rpm&#39;: {1: 0.85899385207057188,
  3: 0.88634665981443039,
  5: 0.90984280257609562,
  7: 0.90757986581712302,
  9: 0.90022237747155309},
 &#39;stroke&#39;: {1: 0.91796375714948086,
  3: 0.88113492952413897,
  5: 0.89586641314603555,
  7: 0.94574853212680499,
  9: 0.92121730389055356},
 &#39;wheel_base&#39;: {1: 0.70984063675235898,
  3: 0.70981264790591259,
  5: 0.70662378566203043,
  7: 0.71073380297018984,
  9: 0.72499494497288963},
 &#39;width&#39;: {1: 0.77543242861316763,
  3: 0.68812005931548847,
  5: 0.67160814824580428,
  7: 0.5826291501627695,
  9: 0.56790774193128279}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Generally speaking, just eyeballing within each predictor, going up to k = 9 worked the best for some of the models, but not for others. The error actually went up as we increased k for some. With a k of 9, the best univariate predictor seems to be engine size, with predictions only off by about half a standard deviation. So thats the best so far, but it&amp;rsquo;s still not great. When trying to predict an outcome, univariate models aren&amp;rsquo;t going to be extremely informative. Outcomes are complex, so let&amp;rsquo;s build a model that reflects that and takes in more than one column.&lt;/p&gt;
&lt;p&gt;What I&amp;rsquo;ve done to accomplish this is modified the above function to take multiple columns and then train and test some models using the the best two, then three, four, and five columns from above. By eyeballing at the 5-nearest neighbours level, the columns that predict the best in isolation are engine size, highway mpg, curb_weight, horsepower, and city mpg.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def knn_train_test_mult(train_cols, target_col, df):
    np.random.seed(1)
        
    # Randomize order of rows in data frame.
    shuffled_index = np.random.permutation(df.index)
    rand_df = df.reindex(shuffled_index)

    # Divide number of rows in half and round.
    last_train_row = int(len(rand_df) / 2)
    
    # Select the first half and set as training set.
    # Select the second half and set as test set.
    train_df = rand_df.iloc[0:last_train_row]
    test_df = rand_df.iloc[last_train_row:]
    
    k_values = [5]
    k_rmses = {}
    
    for k in k_values:
        # Fit model using k nearest neighbors.
        knn = KNeighborsRegressor(n_neighbors=k)
        knn.fit(train_df[train_cols], train_df[target_col])

        # Make predictions using model.
        predicted_labels = knn.predict(test_df[train_cols])

        # Calculate and return RMSE.
        mse = mean_squared_error(test_df[target_col], predicted_labels)
        rmse = np.sqrt(mse)
        
        k_rmses[k] = rmse
    return k_rmses

train_cols_2 = [&#39;engine_size&#39;, &#39;highway_mpg&#39;]
train_cols_3 = [&#39;engine_size&#39;, &#39;highway_mpg&#39;, &#39;curb_weight&#39;]
train_cols_4 = [&#39;engine_size&#39;, &#39;highway_mpg&#39;, &#39;curb_weight&#39;,
               &#39;horsepower&#39;]
train_cols_5 = [&#39;engine_size&#39;, &#39;highway_mpg&#39;, &#39;curb_weight&#39;,
               &#39;horsepower&#39;, &#39;city_mpg&#39;]

k_rmse_results = {}

rmse_val = knn_train_test_mult(train_cols_2, &#39;price&#39;, normalized_cars)
k_rmse_results[&amp;quot;two best features&amp;quot;] = rmse_val
rmse_val = knn_train_test_mult(train_cols_3, &#39;price&#39;, normalized_cars)
k_rmse_results[&amp;quot;three best features&amp;quot;] = rmse_val
rmse_val = knn_train_test_mult(train_cols_4, &#39;price&#39;, normalized_cars)
k_rmse_results[&amp;quot;four best features&amp;quot;] = rmse_val
rmse_val = knn_train_test_mult(train_cols_5, &#39;price&#39;, normalized_cars)
k_rmse_results[&amp;quot;five best features&amp;quot;] = rmse_val

k_rmse_results
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&#39;five best features&#39;: {5: 0.49634970383078636},
 &#39;four best features&#39;: {5: 0.48157162981314988},
 &#39;three best features&#39;: {5: 0.50707231602531166},
 &#39;two best features&#39;: {5: 0.43695579560820619}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, what we have here is four new models that combine the best features we identified above. For example, the two best features model is using engine size and highway mpg to predict sale price with k set to 5. The three best predictors model is using engine size, highway mpg, and curb weight. Interestingly, adding more predictors does not increase the performance of the model at all - in fact, it makes it worse. This is not at all surprising because we started with the two best predictors, and just tacked on worse and worse predictors. So simply adding more doesn&amp;rsquo;t do anything good for us, it just adds muddier predictors to the model.&lt;/p&gt;
&lt;p&gt;The best performing model here to predict the price of a car is simply it&amp;rsquo;s engine size and highway miles per gallon. Let&amp;rsquo;s combine the two tests we&amp;rsquo;ve done so far and go a little overboard with it. Let&amp;rsquo;s test are four multivariate models at all ks ranging from 1 to 25.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def knn_train_test_mult(train_cols, target_col, df):
    np.random.seed(1)
        
    # Randomize order of rows in data frame.
    shuffled_index = np.random.permutation(df.index)
    rand_df = df.reindex(shuffled_index)

    # Divide number of rows in half and round.
    last_train_row = int(len(rand_df) / 2)
    
    # Select the first half and set as training set.
    # Select the second half and set as test set.
    train_df = rand_df.iloc[0:last_train_row]
    test_df = rand_df.iloc[last_train_row:]
    
    k_values = list(range(1,25))
    k_rmses = {}
    
    for k in k_values:
        # Fit model using k nearest neighbors.
        knn = KNeighborsRegressor(n_neighbors=k)
        knn.fit(train_df[train_cols], train_df[target_col])

        # Make predictions using model.
        predicted_labels = knn.predict(test_df[train_cols])

        # Calculate and return RMSE.
        mse = mean_squared_error(test_df[target_col], predicted_labels)
        rmse = np.sqrt(mse)
        
        k_rmses[k] = rmse
    return k_rmses

k_rmse_results_2 = {}

rmse_val = knn_train_test_mult(train_cols_2, &#39;price&#39;, normalized_cars)
k_rmse_results_2[&amp;quot;two best features&amp;quot;] = rmse_val
rmse_val = knn_train_test_mult(train_cols_3, &#39;price&#39;, normalized_cars)
k_rmse_results_2[&amp;quot;three best features&amp;quot;] = rmse_val
rmse_val = knn_train_test_mult(train_cols_4, &#39;price&#39;, normalized_cars)
k_rmse_results_2[&amp;quot;four best features&amp;quot;] = rmse_val
rmse_val = knn_train_test_mult(train_cols_5, &#39;price&#39;, normalized_cars)
k_rmse_results_2[&amp;quot;five best features&amp;quot;] = rmse_val

k_rmse_results_2

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&#39;five best features&#39;: {1: 0.48370851070283638,
  2: 0.45709593736092696,
  3: 0.45932846135166017,
  4: 0.47702516372024495,
  5: 0.49634970383078636,
  6: 0.51326367838750764,
  7: 0.49909158266517145,
  8: 0.49234720868686166,
  9: 0.49925986215124729,
  10: 0.50320132862625788,
  11: 0.49352187011331128,
  12: 0.50969596379759741,
  13: 0.51666729281793589,
  14: 0.52430330537451841,
  15: 0.52831175797337293,
  16: 0.53372729477563852,
  17: 0.53629514907736431,
  18: 0.53771760713738892,
  19: 0.54366780131360726,
  20: 0.55390626006954025,
  21: 0.56186625263562961,
  22: 0.56399228907515964,
  23: 0.56686293421110434,
  24: 0.56749133395228601},
 &#39;four best features&#39;: {1: 0.46011695087263338,
  2: 0.47254209382853879,
  3: 0.4957675847479055,
  4: 0.47457606714743178,
  5: 0.48157162981314988,
  6: 0.4988487989184765,
  7: 0.51321993316267744,
  8: 0.51485477394479984,
  9: 0.51767653423898286,
  10: 0.5323478616627898,
  11: 0.51621784291210482,
  12: 0.51180481420952084,
  13: 0.52093660357028182,
  14: 0.5264585716201885,
  15: 0.53375627848681184,
  16: 0.53867876043121632,
  17: 0.539751445854185,
  18: 0.54052905274747964,
  19: 0.54394381259000146,
  20: 0.55263828123323866,
  21: 0.55895871633176053,
  22: 0.56273074037859749,
  23: 0.55965116497813094,
  24: 0.56079209060485291},
 &#39;three best features&#39;: {1: 0.53304672541629627,
  2: 0.47236953984714419,
  3: 0.48544239785342919,
  4: 0.46468465687861726,
  5: 0.50707231602531166,
  6: 0.50672338800144279,
  7: 0.52042141176821866,
  8: 0.51959755832321974,
  9: 0.51531096459267978,
  10: 0.52080169867439063,
  11: 0.52322240088596494,
  12: 0.52075280982124794,
  13: 0.51183217030638006,
  14: 0.51868070682253542,
  15: 0.52774088364145721,
  16: 0.53035523273810814,
  17: 0.53183552745587126,
  18: 0.53451532836203997,
  19: 0.54155167597224763,
  20: 0.54551779898598018,
  21: 0.54674295619522062,
  22: 0.54707824469373634,
  23: 0.54985793303062935,
  24: 0.55512440029648535},
 &#39;two best features&#39;: {1: 0.4962211708123152,
  2: 0.42439666654800412,
  3: 0.37244955551446796,
  4: 0.38221587546513652,
  5: 0.43695579560820619,
  6: 0.49363489340281513,
  7: 0.50823941279743867,
  8: 0.51418965195989808,
  9: 0.52616341995960625,
  10: 0.53013621032483371,
  11: 0.53671709358748898,
  12: 0.53444184258976579,
  13: 0.51587142155192167,
  14: 0.51205713655316698,
  15: 0.5119686970820041,
  16: 0.51750488428455055,
  17: 0.52218955380387977,
  18: 0.53175784405886029,
  19: 0.54377416147308744,
  20: 0.54302569583633942,
  21: 0.54968364588915308,
  22: 0.5508362135961884,
  23: 0.55132842211110611,
  24: 0.55665088230669157}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can probably tell, it&amp;rsquo;s hard to make sense of this. For our different models with 2, 3, 4, and 5 predictors, what is the most accurate value of k? The best way to explore this might be just to plot it out! So, I&amp;rsquo;ll take the big dictionary that&amp;rsquo;s printed above and plot it out with RMSE on the y axis, k on the x axis, and then each colored line is a different model.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pyplot as plt
% matplotlib inline

for k,v in k_rmse_results_2.items():
    x = list(v.keys())
    y = list(v.values())
    
    plt.plot(x,y)
    plt.xlabel(&#39;k value&#39;)
    plt.ylabel(&#39;RMSE&#39;)
    
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=figure&gt;&lt;img src=/project/Car_Prices/output_27_0.png&gt;&lt;/div&gt;
&lt;p&gt;The pattern you can discern just looking at the numbers becomes clear here when looking at the graph. The best models for any given set of predictors is right around a k of 3-5. Once we start adding more than that, the performance of the model gets worse.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;So, we&amp;rsquo;ve learned a lot about how to run a KNN regression using python, how to tweak paramaters like the number of predictors in a model and the number of neighbors we use, and how to evaluate those models.&lt;/p&gt;
&lt;p&gt;From this, we learned in our simple set of predictions that the most accurate model is using just the two best predictors, engine size and highway miles per gallon, with k set somewhere in the 3-5 range.&lt;/p&gt;
&lt;p&gt;I hope you found this tutorial helpful, and I encourage you to give it a shot for yourself using this dataset, or any other, from UCI&amp;rsquo;s rich machine learning repository!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
